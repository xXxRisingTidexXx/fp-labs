#lang racket
(define (objective)
  ; Повертає аргумент, значення функції для користувацького sin та абсолютну похибку.
  (define (estimate x)
    ; Результат - список фіксованої довжини з 3 елементів.
    (append (list x) (absolute-error (y sin x) (y lab-sin x))))
  ; Знаходить абсолютну похибку між аналітичним і наближеним значенням функції.
  (define (absolute-error y1 y2)
    ; Результат у вигляді списку, щоб простіше злити значення на попередньому етапі.
    (list y2 (abs (- y2 y1))))
  ; Обрахунок функції для заданого способу обчислення х.
  (define (y sine x)
    ; Якщо аргумент належить області визначення, то застосовуємо формулу. Інакше - nan.
    (cond
      ((and (<= -2 x) (<= x 0)) (+ (expt (sine x) 3) (sine (* 2 x))))
      ((and (< 0 x) (<= x 1)) (- (sqr (sine x)) (sine x)))
      (else +nan.0)))
  ; Генеруємо простір аргументів і поелементно застосовуємо функцію.
  (map estimate (range -2 2.1 0.5)))

(define (lab-sin x)
  ; Обраховує суму i членів ряду Тейлора з оглядом на абсолютну похибку.
  (define (partial-lab-sin i previous current)
    (if
     ; Якщо ітерація не є першою й абсолютна похибка стала незначущою ...
     (and (> i 0) (< (abs (- current previous)) 1e-6))
     ; ... то повертаємо накопичене значення.
     previous
     ; Інкаше ж - включаємо ще один доданок.
     (partial-lab-sin
      ; Інкрементуємо індекс доданку.
      (+ i 1)
      ; "Поточна" сума буде "попередньою". 
      current
      ; А "наступна" - "поточною".
      (+ current (* (expt -1 i) (/ (expt x (+ (* 2 i) 1)) (factorial (+ (* 2 i) 1))))))))
  ; Сума й індекс починаються з 0. Остаточний результат перетворюємо з дробу в дійсне число. 
  (exact->inexact (partial-lab-sin 0 0 0)))

(define (factorial n)
  ; Обрахунок факторіалу йде з хвоста.
  (define (partial-factorial m a)
    (if
     ; Якщо дійшли до 0 чи 1 множника ...
     (<= m 1)
     ; ... то повертаємо накопичене значення.
     a
     ; Інакше ж включаємо ще один елемент у добуток.
     (partial-factorial (- m 1) (* m a))))
  ; Кожен добуток починається з 0. Випадок 0! = 1 також оброблюється.
  (partial-factorial n 1))

(define (pythagorean-triples n)
  ; Для піфагорових трійок скористаємося формулою Евкліда.
  (define (append-triple x y triples)
    (cond
      ; Якщо параметри генерують гіпотенузу, що перевищує ліміт - закінчуємо генерацію.
      ((> (+ (sqr x) (sqr y)) n) triples)
      ; Слідуємо правилу, що один з параметрів строго менший за другий.
      ((= x y) (append-triple 1 (+ y 1) triples))
      ; Якщо параметри х та у притомні - дописуємо нову трійку.
      (else
       (append-triple
        (+ x 1)
        y
        ; Функціонал append вимагає вкладеність, щоб наприкінці отримати список списків.
        (append triples (list (list (- (sqr y) (sqr x)) (* 2 x y) (+ (sqr x) (sqr y)))))))))
  ; Усі результати записуємо до списку, який на початку порожній.
  (append-triple 1 2 null))