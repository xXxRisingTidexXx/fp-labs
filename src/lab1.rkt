#lang racket
(define (ones n)
  ; Закінчуємо, коли отримали 0.
  (if (= n 0)
      0
      ; Інкрементуємо лічильник одиниць. Через побітове "і" відсікаємо нулі й розряди.
      (+ 1 (ones (bitwise-and n (- n 1))))))

(define (tail-ones n)
  ; Замикання для хвостової рекурсії. Включає початкове число, накопичені одиниці й глибину.
  (define (partial-ones n a d)
    ; Закінчуємо, коли отримали 0.
    (if (= n 0)
        ; Повертаємо також кількість рекурентних викликів.
        (values a d)
        ; Аналогічним чином зменшуємо число й інкрементуємо знайдені одинички й виклики.
        (partial-ones (bitwise-and n (- n 1)) (+ 1 a) (+ 1 d))))
  ; На самому початку нема ні одиниць, ні рекурсивних викликів.
  (partial-ones n 0 0))

(define (tail-stamps m x y z)
  ; Замикання для хвостової рекурсії. Включає вартість відправлення, лічильник марок x,
  ; вартість марок x, лічильник марок y, вартість марок y, лічильник марок z, вартість
  ; марок z i комбінації.
  (define (partial-stamps m a x b y c z q)
    ; Умови для перебору всіх комбінацій x, y & z.
    (cond
      ; Якщо сума марок x перевищила відправлення - годі лічити.
      ((> (* a x) m) q)
      ; Якщо сума марок y перевищила відправлення - починаємо новий обхід з +1 маркою х.
      ((> (* b y) m) (partial-stamps m (+ 1 a) x 0 y 0 z q))
      ; Якщо сума марок z перевищила відправлення - починаємо новий обхід з +1 маркою y.
      ((> (* c z) m) (partial-stamps m a x (+ 1 b) y 0 z q))
      ; Якщо комбінація всіх марок рівняється m - інкрементуємо лічильник комбінацій.
      ((= (+ (* a x) (+ (* b y) (* c z))) m) (partial-stamps m a x b y (+ 1 c) z (+ 1 q)))
      ; Інакше ж просто намагаємося дібрати ще одну марку z.
      (else (partial-stamps m a x b y (+ 1 c) z q))))
  ; Починаємо без марок і з нульовою кількістю.
  (partial-stamps m 0 x 0 y 0 z 0))