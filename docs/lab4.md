---
title: Лабораторна робота №4
description: Програмування списків мовами функціонального програмування
---
## Зміст

* TOC
{:toc}

## Мета

Опанувати теоретичні основи використання списків функціональними мовами та розробити програми обробки списків.

## Завдання

1. Створити список чисел або символів. Виконати такі операції:

    - Обчислити кількість елементів у найдовшій серії, вивести усі серії та шукану кількість. Серія — це послідовність
        однакових елементів, розташованих поспіль.
    - В кожній серії списку залишити по одному елементу та надрукувати список.
    - Додати на початок списку `n` елементів, кратних заданому користувачем числу.

2. Написати код, що моделює процес прийняття фахівця на роботу. На вакантну посаду подано k резюме, з яких сформовано
    список. Попередній аналіз визначив пріоритети резюме. В результаті сформований новий список, в якому резюме
    відсортовані за пріоритетом. Вищий пріоритет має нижчий номер. На співбесіду допущено `m, m < k` резюме. В процесі
    проходження 1 туру співбесіди `n, n < m` людей отримали відмову. В процесі проходження 2 туру відмовлено
    `p, p < m - n` людям. Решту людей взяли на випробувальний термін. Вивести на екран сценарій модифікації списків в
    процесі походження 1, 2 турів та випробувального періоду. Запропонувати сценарій вибору одної людини після
    випробувального періоду.

## Мова та IDE

В якості мови програмування була обрана [racket](https://racket-lang.org/), оскільки вона є строго функціональною. В
якості середовища розробки було обрано супутній редактор DrRacket.

## Реалізація

### Задача 1

В цій задачі рішення доволі тривіальне - необхідно розбити вхідну послідовність на підпослідовності однакових
елементів. Для цього необхідно й достатньо ітеруватися вхідною послідовністю й порівнювати кожну комірку з
останньою серією. При відмінності поточний елемнет формуватиме нову серію, інакше увійде до останньої. Для
обрахунку найдовшої серії потрібно обрахувати їхні довжини й знайти нійбільшу. Серії без дублікатів формуються,
як виклик `car` для кожної з них.

```
(define (objective1 elements n v)
  ; Перша задача потребує розбити список на підпослідовності однакових елементів.
  (define (bite series items)
    ; В цій процедурі ми йдемо вздовж вхідних даних і по одному елементу дописуємо в серії.
    (if
     ; Якщо нема чого дописувати ...
     (empty? items)
     ; ... то всі серії вже обраховані.
     series
     (let
         ; Добудемо елемент, який потрібно дописати.
         ((item (car items)))
       (if
        ; Якщо нема жодної серії чи знайдене значення відрізняється від попереднього ...
        (or (empty? series) (not (= item (car (last series)))))
        ; ... то дописуємо новий вкладений список.
        (bite (append series (list (list item))) (cdr items))
        ; Інакше ж модифікуємо останню серію.
        (bite
         (append
          ; Відкидаємо стару серію ...
          (reverse (cdr (reverse series)))
          ; ... й дописуємо модифіковану з поточним елементом.
          (list (append (last series) (list item))))
         (cdr items))))))
  (define (maximum series)
    ; В поточній процедурі визначається максимальна довжина серії.
    (let
        ; Для цього треба обрахувати список довжин.
        ((lengths (map length series)))
      ; І через операцію згортки знайти найбільшу.
      (foldr max (first lengths) (rest lengths))))
  (define (multiples)
    ; Дана функція генерує n чисел, що кратні заданому користувачем значенню.
    (map (lambda (i) (* i v)) (range 2 (+ 2 n))))
  (let
      ; На початку обрахунку серій список списків порожній.
      ((sequences (bite '() elements)))
    ; Наприкінці повертаємо ...
    (values
     ; ... самі серії, ...
     sequences
     ; ... довжину найдовшої серії, ...
     (maximum sequences)
     ; ... список без дублікатів ...
     (map car sequences)
     ; ... та кратні елементи з дописаним списком.
     (append (multiples) elements))))
```

Приклади результатів роботи:

```
> (objective1 '(1 1 1 3 4 4 5 1 0 9 9) 3 4)
'((1 1 1) (3) (4 4) (5) (1) (0) (9 9))
3
'(1 3 4 5 1 0 9)
'(8 12 16 1 1 1 3 4 4 5 1 0 9 9)
> (objective1 '(1 3 3 0 9 9 0 8 1) 2 10)
'((1) (3 3) (0) (9 9) (0) (8) (1))
2
'(1 3 0 9 0 8 1)
'(20 30 1 3 3 0 9 9 0 8 1)
```

### Задача 2

По суті, необхідно згенерувати випадкові скори кожному кандидату, присвоїти унікальний ID і провести кілька
селекцій. Кожне повторення відбору включає відбір l кандидатів з найвищим пріоритетом й випадкова зміна рейтингу.
Це симулює проходження чергового етапу співбесіди. Наприкінці кандидат з найвищим пріоритетом вважається переможцем.

```
(define (objective2 k m n p)
  ; Симуляція процесу відбору включає 4 параметри кількості кандидатів і відсіяння.
  (define (select-candidates candidates l)
    ; У відборі кандидатів добираються l осіб з найвищчими пріоритетами, після чого 
    ; переможці отримують випадкові модифікації скорів. Це симулює перерахунок рейтингу
    ; перед черговим переглядом з боку рекрутерів.
    (map
     ; Емпірично підібрана формула зміни рейтингу.
     (lambda (c) (list (first c) (+ (second c) (* 0.5 (random)) -0.3)))
     ; Відбір l найбільш відповідних кандидатів.
     (take (sort candidates (lambda (c1 c2) (< (second c1) (second c2)))) l)))
  (let
      ; Початкова множина претендентів.
      ((selection (map (lambda (i) (list i (random))) (range k))))
    (display "Номери та пріоритети кандидатів на відборі:\n")
    (display selection)
    (newline)
    (let
        ; Обчислення тих, хто пройшли в 1 тур.
        ((tour1 (select-candidates selection m)))
      (display "Номери та пріоритети кандидатів у 1 турі:\n")
      (display tour1)
      (newline)
      (let
          ; Обчислення тих, хто пройшли в 2 тур.
          ((tour2 (select-candidates tour1 (- m n))))
        (display "Номери та пріоритети кандидатів у 2 турі:\n")
        (display tour2)
        (newline)
        (let
            ; Обчислення тих, хто пройшли на випробувальний термін.
            ((probation (select-candidates tour2 (- m n p))))
          (display "Номери та пріоритети кандидатів на випробувальному терміні:\n")
          (display probation)
          (newline)
          (display "Номер та пріоритет переможця відбору:\n")
          ; Обрахунок переможця конкурсу.
          (display (car (select-candidates probation 1))))))))
```

Приклади результатів роботи:

```
> (objective2 6 4 1 1)
Номери та пріоритети кандидатів на відборі:
((0 0.15020954102361217)
 (1 0.1684351177035143)
 (2 0.33927067685134266)
 (3 0.9550202141153172)
 (4 0.8790427776614432)
 (5 0.5156039659040107))
Номери та пріоритети кандидатів у 1 турі:
((0 0.30893228630486785) (1 -0.1298527718543486) (2 0.46865024268144057) (5 0.27456118613684716))
Номери та пріоритети кандидатів у 2 турі:
((1 0.027215577513175215) (5 -0.02531921562421985) (0 0.2210515786844141))
Номери та пріоритети кандидатів на випробувальному терміні:
((5 -0.13596645544306893) (1 -0.02151463510818863))
Номер та пріоритет переможця відбору:
(5 -0.3267936888321039)
```

## Висновки

Списки в Racket - основні колекції даних, з якими здійснюються операції фільтрації, конвертації, сортування, зміни
порядку. Під капотом список в SCHEME реалізований, як послідовність пар. Дана колекція даних є гетерогенною, тобто
може містити значення різних типів. З допомогою списків зручно моделювати бізнес-процеси, адже вони дають повний
контроль над найбільш різноманітними операціями з масивами інформації.
