---
title: Лабораторна робота №1
description: Використання рекурсії для організації повторюваних процесів
---
## Зміст

{:toc}

## Мета

Сформувати декларативне мислення в галузі програмування завдяки використанню чистих функцій, рекурсій замість циклів,
запобіганню даних, що змінюються. Опанувати застосування рекурсивних функцій для обчислювальних процесів.

## Завдання

Написати процедури, що обчислюють задану функцію за допомогою рекурсивного процесу. Продемонструвати застосування
звичайної та хвостової рекурсії.

1. Ввести ціле число n в десятковій системі числення з клавіатури. Перевести його у двійкову систему. Знайти кількість
    одиниць у двійковому представленні числа n, використовуючи рекурентне означення функції f(n), де символ & означує
    операцію побітового логічного множення.

    ![formula](https://render.githubusercontent.com/render/math?math=f%28n%29%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20n%3D0%20%5C%5C%201%2Bf%28n%5C%26%28n%2B1%29%29%2C%20%26%20n%20%5Cneq%200%20%5Cend%7Bcases%7D)

    Реалізувати рекурсивний варіант розв'язку задачі. Визначити глибину рекурсії.

2. Потрібно сплатити поштове відправлення, вартість котрого складає m копійок, а в наявності тільки поштові марки
    номіналом x, y, z копійок. Скількома різними способами можна сплатити поштове відправлення? Розробити рекурсивну
    функцію для обчислення кількості зображень числа m у вигляді суми певних фіксованих чисел з використанням рекурентних
    співвідношень. Використати рекурентне співвідношення для чисел Фібоначчі.

## Мова та IDE

В якості мови програмування була обрана [racket](https://racket-lang.org/), оскільки вона є строго функціональною. В
якості середовища розробки було обрано супутній редактор DrRacket.

## Реалізація

### Задача 1

Імплементація через звичайну рекурсію. Використовується вбудована функція для зменшення розрядів у двійковому
представленні.

```
(define (ones n)
  ; Закінчуємо, коли отримали 0.
  (if (= n 0)
      0
      ; Інкрементуємо лічильник одиниць. Через побітове "і" відсікаємо нулі й розряди.
      (+ 1 (ones (bitwise-and n (- n 1))))))
```

Вирішення з хвостовою рекурсією відрізняється наявністю замикання і перенесенням лічильника одиниць в його аргументи.

```
(define (tail-ones n)
  ; Замикання для хвостової рекурсії. Включає початкове число, накопичені одиниці й глибину.
  (define (partial-ones n a d)
    ; Закінчуємо, коли отримали 0.
    (if (= n 0)
        ; Повертаємо також кількість рекурентних викликів.
        (values a d)
        ; Аналогічним чином зменшуємо число й інкрементуємо знайдені одинички й виклики.
        (partial-ones (bitwise-and n (- n 1)) (+ 1 a) (+ 1 d))))
  ; На самому початку нема ні одиниць, ні рекурсивних викликів.
  (partial-ones n 0 0))
```

Пристуні й приклади обчислень. Друга реалізація також повертає кількість рекурсивних викликів.

```
> (ones 0)
0
> (ones 1)
1
> (ones 1023)
10
> (ones 4096)
1
> (ones 2739423)
14
> (tail-ones 0)
0
1
> (tail-ones 1)
1
2
> (tail-ones 1023)
10
11
> (tail-ones 4096)
1
2
> (tail-ones 2739423)
14
15
```

### Задача 2

Тут наявне рішення через хвостову рекурсію. Вона еквівалентна циклам в класичних мовах програмування, що перевіряють
комбінації марок на рівність сумі. Перебір можливих варіантів потребує меж. Для цього я визначив крайні значення
кількостей кожної з марок. Кожна з них може бути не використана взагалі як мінімум, а максимум - `m // x`, де `//` -
ціла частина від ділення двох чисел. Всього буде виконано `(m // x) * (m // y) * (m // z)` ітерацій.

```
(define (tail-stamps m x y z)
  ; Замикання для хвостової рекурсії. Включає вартість відправлення, лічильник марок x,
  ; вартість марок x, лічильник марок y, вартість марок y, лічильник марок z, вартість
  ; марок z i комбінації.
  (define (partial-stamps m a x b y c z q)
    ; Умови для перебору всіх комбінацій x, y & z.
    (cond
      ; Якщо сума марок x перевищила відправлення - годі лічити.
      ((> (* a x) m) q)
      ; Якщо сума марок y перевищила відправлення - починаємо новий обхід з +1 маркою х.
      ((> (* b y) m) (partial-stamps m (+ 1 a) x 0 y 0 z q))
      ; Якщо сума марок z перевищила відправлення - починаємо новий обхід з +1 маркою y.
      ((> (* c z) m) (partial-stamps m a x (+ 1 b) y 0 z q))
      ; Якщо комбінація всіх марок рівняється m - інкрементуємо лічильник комбінацій.
      ((= (+ (* a x) (+ (* b y) (* c z))) m) (partial-stamps m a x b y (+ 1 c) z (+ 1 q)))
      ; Інакше ж просто намагаємося дібрати ще одну марку z.
      (else (partial-stamps m a x b y (+ 1 c) z q))))
  ; Починаємо без марок і з нульовою кількістю.
  (partial-stamps m 0 x 0 y 0 z 0))
```

Приклади функціонування є такими:

```
> (tail-stamps 200 201 202 203)
0
> (tail-stamps 200 29 37 12)
2
> (tail-stamps 200 35 3 2)
115
> (tail-stamps 200 20 30 40)
14
> (tail-stamps 10 2 3 5)
4
> (tail-stamps 20 7 11 4)
1
> (tail-stamps 35 10 13 6)
1
> (tail-stamps 35 10 13 7)
1
```

## Висновки

Строго функціональні мови програмування виділяються на фоні класичних по типу C, Go, Python і тд. Їхня парадигма
змушує розглядати будь-яку сутність коду як виконувану дію. Нестача операторів присвоювання й циклів також сказується
на мінімально необхідному порозі знань для ознайомлення. Однак навіть хвостова рекурсія з практикою починає виглядати
новаторським підходом, чия специфіка переінакшує звичні алгоритми на новий лад. ФП веде до декларативного стилю
програмування, що в цілому розширює інженерний світогляд.
