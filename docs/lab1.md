---
title: Лабораторна робота №1
description: Використання рекурсії для організації повторюваних процесів
---

## Мета

Сформувати декларативне мислення в галузі програмування завдяки використанню чистих функцій, рекурсій замість циклів,
запобіганню даних, що змінюються. Опанувати застосування рекурсивних функцій для обчислювальних процесів.

## Завдання

Написати процедури, що обчислюють задану функцію за допомогою рекурсивного процесу. Продемонструвати застосування
звичайної та хвостової рекурсії.

1. Ввести ціле число n в десятковій системі числення з клавіатури. Перевести його у двійкову систему. Знайти кількість
    одиниць у двійковому представленні числа n, використовуючи рекурентне означення функції f(n), де символ & означує
    операцію побітового логічного множення.

    ![formula](https://render.githubusercontent.com/render/math?math=f%28n%29%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20n%3D0%20%5C%5C%201%2Bf%28n%5C%26%28n%2B1%29%29%2C%20%26%20n%20%5Cneq%200%20%5Cend%7Bcases%7D)

    Реалізувати рекурсивний варіант розв'язку задачі. Визначити глибину рекурсії.

2. Потрібно сплатити поштове відправлення, вартість котрого складає m копійок, а в наявності тільки поштові марки
    номіналом x, y, z копійок. Скількома різними способами можна сплатити поштове відправлення? Розробити рекурсивну
    функцію для обчислення кількості зображень числа m у вигляді суми певних фіксованих чисел з використанням рекурентних
    співвідношень. Використати рекурентне співвідношення для чисел Фібоначчі.

## Мова та IDE

В якості мови програмування була обрана [racket](https://racket-lang.org/), оскільки вона є строго функціональною. В
якості середовища розробки було обрано супутній редактор DrRacket.

## Реалізація

Дана імплементація включає рішення як через звичайну, так і через хвостову рекурсію.

```
(define (ones n)
  (if (= n 0)
      0
      (+ 1 (ones (bitwise-and n (- n 1))))))
(define (tail-ones n)
  (define (partial-ones n a d)
    (if (= n 0)
        (values a (+ 1 d))
        (partial-ones (bitwise-and n (- n 1)) (+ 1 a) (+ 1 d))))
  (partial-ones n 0 0))
```

Пристуні й приклади обчислень. Друга реалізація також повертає кількість рекурсивних викликів.

```
> (ones 0)
0
> (ones 1)
1
> (ones 1023)
10
> (ones 4096)
1
> (ones 2739423)
14
> (tail-ones 0)
0
1
> (tail-ones 1)
1
2
> (tail-ones 1023)
10
11
> (tail-ones 4096)
1
2
> (tail-ones 2739423)
14
15
```

Друга задача наводить рішення через хвостову рекурсію. Тут вона еквівалентна циклам в класичних мовах програмування,
що перевіряють комбінації марок на рівність сумі.

```
(define (tail-stamps m x y z)
  (define (partial-stamps m a x b y c z q)
    (if (> (* a x) m)
        q
        (if (> (* b y) m)
            (partial-stamps m (+ 1 a) x 0 y 0 z q)
            (if (> (* c z) m)
                (partial-stamps m a x (+ 1 b) y 0 z q)
                (if (= (+ (* a x) (+ (* b y) (* c z))) m)
                    (partial-stamps m a x b y (+ 1 c) z (+ 1 q))
                    (partial-stamps m a x b y (+ 1 c) z q))))))
  (partial-stamps m 0 x 0 y 0 z 0))
```

Приклади функціонування є такими:

```
> (tail-stamps 200 201 202 203)
0
> (tail-stamps 200 29 37 12)
2
> (tail-stamps 200 35 3 2)
115
> (tail-stamps 200 20 30 40)
14
> (tail-stamps 10 2 3 5)
4
> (tail-stamps 20 7 11 4)
1
> (tail-stamps 35 10 13 6)
1
> (tail-stamps 35 10 13 7)
1
```

## Висновки

Строго функціональні мови програмування виділяються на фоні класичних по типу C, Go, Python і тд. Їхня парадигма
змушує розглядати будь-яку сутність коду як виконувану дію. Нестача операторів присвоювання й циклів також сказується
на мінімально необхідному порозі знань для ознайомлення. Однак навіть хвостова рекурсія з практикою починає виглядати
новаторським підходом, чия специфіка переінакшує звичні алгоритми на новий лад. ФП веде до декларативного стилю
програмування, що в цілому розширює інженерний світогляд.
