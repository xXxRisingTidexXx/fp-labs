---
title: Лабораторна робота №3
description: Форми lambda та let, вираз присвоєння set! для розв'язання нелінійних рівнянь та чисельного інтегрування функцій
---
## Зміст

* TOC
{:toc}

## Мета

Розв'язати нелінійні рівняння та здійснити чисельне інтегрування функцій наближеними методами, використовуючи мови
функціонального програмування, lambda, let та set! форми.

## Завдання

1. Знайти корені нелінійного рівняння. Пошук наближеного значення хоча б одного кореня рівняння `f(x) = 0` здійснювати
    методом Ньютона. Початкове значення `x` обрати самостійно.

    ![formula](https://quicklatex.com/cache3/f7/ql_468b5e083a84d5b35ef89fd72e8806f7_l3.png)

2. Написати процедури для обчислення інтеграла за формулами й методом трапецій. Порівняти результати обчислення.

    ![formula](https://quicklatex.com/cache3/6f/ql_1a447d3480258c02ebce49e8d15fb26f_l3.png)

## Мова та IDE

В якості мови програмування була обрана [racket](https://racket-lang.org/), оскільки вона є строго функціональною. В
якості середовища розробки було обрано супутній редактор DrRacket.

## Реалізація

### Задача 1

Метод Ньютона (метод дотичних) - проста ітеративна процедура, яка намагається наблизити координати точки дотику до
точки перетину функції з віссю абсцис. Формульно це виглядає так:

![formula](https://quicklatex.com/cache3/57/ql_99a55a20c5e1fbc6f27e3b3aa0b73557_l3.png)

Метод є нескладним, однак примхливим і не завжди результативним. Основний вплив на вирішення має початкова точка
процедури - вона задає не тільки вибір кореня, а й визначає можливість його обрахунку. Наприклад, в поточній задачі
рівняння має 2 корені, обмежену область визначення і "сліпу зону", де метод дотичних не повертає рішення.

```
(define (solve-neuton x)
  ; Метод Ньютона повертає корінь в залежності від початкової точки.
  (if
   ; І якщо ітераційна процедура виходить за область визначення ...
   (<= x -1)
   ; ... то результату немає.
   +nan.0
   ; Однак, допоки значення функції в точці можна обрахувати ...
   (let
      ((f (- (sqr x) (log (+ x 1)) 3)))
    (if
     ; ... то при достатньому наближенні до 0 ...
     (< (abs f) 1e-9)
     ; ... один з коренів буде отриманий.
     x
     ; А поки рішення не зійшлося, обраховуємо похідну й оновлюємо абсцису дотику.
     (solve-neuton (- x (/ f (- (* 2 x) (/ 1 (+ x 1))))))))))
```

Давайте ж поглянемо, як на результат впливає початкова координата. В тих випадках, де провести дотичну неможливо,
функція повертає `nan`.

```
> (solve-neuton -10)
+nan.0
> (solve-neuton -0.99)
-0.8900574880065422
> (solve-neuton -0.85)
-0.8900574880065492
> (solve-neuton 0)
+nan.0
> (solve-neuton 0.3)
+nan.0
> (solve-neuton 2.2)
2.0266892633235543
> (solve-neuton 18)
2.0266892632569267
```

### Задача 2

Аналітично заданий інтеграл спрощується до такої первісної:

![formula](https://quicklatex.com/cache3/2e/ql_34e859266ef8a3ac5819b5f1c502642e_l3.png)

Якщо ж вирішувати його чисельно, з допомогою методу трапецій:

![formula](https://quicklatex.com/cache3/ab/ql_5df98350f29de0ca4eaa1cb73f010fab_l3.png)

То неодмінно зіштовхнемося з проблемою підбору оптимального числа трапецій.

```
(define (integrate-symbol)
  ; Дана первісна була виведена аналітично з підінтегрального виразу.
  (define (integrate x)
    (* (/ x 2) (sqrt (+ (sqr x) 1))))
  ; За формулою Ньютона-Лейбніца знаходимо площу під кривою.
  (- (integrate 1.6) (integrate 0.5)))

(define (integrate-trapezoid n)
  ; Дана рекурсія обраховує суму площ трапецій, допоки не перебере їх усі.
  (define (integrate xi0 xi1 xn sum)
    (if
     ; Якщо "ліва" основа трапеції достатньо порівнялася з кінцем проміжку ...
     (<= (abs (- xn xi0)) 1e-6)
     ; ... то накопичену суму можна вважати розв'язком.
     sum
     ; Інакше ж продовжуємо ходу.
     (integrate
      ; "Права" основа трапеції буде "лівою".
      xi1
      ; До неї ж додамо крок інтегрування, це буде нова "права" основа.
      (- (* 2 xi1) xi0)
      ; Незмінною залишається межа
      xn
      ; А сума збільшується на площу поточної трапеції. Її висота - різниця абсцис, середня
      ; лінія - півсума ординат, а площа - добуток цих виразів.
      (+ sum (* (- xi1 xi0) (/ (+ (estimate xi0) (estimate xi1)) 2))))))
  ; Задаємо формулу підінтегрального виразу.
  (define (estimate x)
    (/ (+ (sqr x) 0.5) (sqrt (+ (sqr x) 1))))
  ; Вказуємо нижню й верхню межу інтегрування.
  (let
      ((a 0.5)
       (b 1.6))
    ; На початку визначаємо крок h i нульову суму.
    (integrate a (+ a (/ (- b a) n)) b 0)))
```

Ось така точність для аналітичного й чисельного рішення:

```
> (integrate-symbol)
1.2299284839415832
> (integrate-trapezoid 1)
1.2609394323128174
> (integrate-trapezoid 5)
1.2312986762065945
> (integrate-trapezoid 50)
1.229942237101614
> (integrate-trapezoid 400)
1.2299286988426172
```

Влучність чисельного рішення наближається до аналітичного при поділі на сотні трапецій.

## Висновки

Обчислювальні методи - один з небагатьох доступних способів за притомний час розв'язати ту чи іншу нелінійну задачу.
І функціональні мови дуже успішні на цьому поприщі, вони надають багатий функціонал для операцій над послідовностями
й ітеративними процедурами. В той же час, оператори присвоювання в межах власного контексту спрощують і скорочують
код, адже сприяють перевикористанню вже набутих значень.
